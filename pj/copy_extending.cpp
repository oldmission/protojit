#include <map>

#include <llvm/ADT/SmallSet.h>
#include <llvm/Analysis/AliasAnalysis.h>
#include <llvm/Analysis/LazyValueInfo.h>
#include <llvm/Analysis/TargetLibraryInfo.h>
#include <llvm/IR/Dominators.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Instructions.h>
#include <llvm/MC/MCSubtargetInfo.h>
#include <llvm/Pass.h>
#include <llvm/Target/TargetMachine.h>
#include "llvm/IR/ConstantRange.h"

#include <pj/util.hpp>

#include "llvm_utils.hpp"
#include "passes.hpp"

namespace llvm {
void initializeCopyExtendingPass(PassRegistry&);

bool operator<(BasicBlock::iterator a, BasicBlock::iterator b) {
  return a.getNodePtr() < b.getNodePtr();
}
}  // namespace llvm

using namespace llvm;
using namespace llvm_utils;

namespace {

struct BoundedCopy {
  static std::optional<BoundedCopy> match(LazyValueInfo& lvi,
                                          const DataLayout& layout,
                                          Instruction* inst) {
    MemCpyInst* memcpy = dyn_cast<MemCpyInst>(inst);
    if (!memcpy) return {};

    auto* len = memcpy->getLength();
    auto bound =
        lvi.getConstantRange(len, memcpy).getUnsignedMax().getLimitedValue();

    auto [load_root, load_base] = getRegionRoot(layout, memcpy->getSource());
    auto [store_root, store_base] = getRegionRoot(layout, memcpy->getDest());

    return BoundedCopy{.memcpy = memcpy,
                       .src_def = load_root,
                       .dst_def = store_root,
                       .src_start = memcpy->getSource(),
                       .dst_start = memcpy->getDest(),
                       .src_start_offset = load_base,
                       .dst_start_offset = store_base,
                       .bound = bound};
  }

  MemCpyInst* memcpy;

  Value* src_def;
  Value* dst_def;

  Value* src_start;
  Value* dst_start;

  size_t src_start_offset;
  size_t dst_start_offset;

  size_t bound;
};

struct PoisonRegion {
  static std::optional<PoisonRegion> match(AAResults& aliasing,
                                           const DataLayout& layout,
                                           Instruction* inst) {
    IntrinsicInst* poison = dyn_cast<IntrinsicInst>(inst);
    if (!poison) return {};
    if (poison->getIntrinsicID() != Intrinsic::memset) return {};
    if (!isa<UndefValue>(poison->getOperand(1))) return {};

    auto* len = dyn_cast<ConstantInt>(poison->getOperand(2));
    if (!len) return {};

    auto [store_root, store_base] =
        getRegionRoot(layout, poison->getOperand(0));

    auto it = poison->getNextNonDebugInstruction()->getIterator();

    return PoisonRegion{
        .pos = it,
        .def = store_root,
        .start = poison->getOperand(0),
        .start_offset = store_base,
        .len = len->getZExtValue(),
    };
  }

  // We define the frontier F of a poison region generated by instruction P as
  // the set of "first" instructions that may overwrite the poison with other
  // values, meaning such stores can be modified to overwrite the entire poison
  // region. More specifically, the set is defined to contain every instruction
  // I such that P dominates I, I may store to the poison region, and there is
  // no other instruction I' matching the first two criteria on any path from P
  // to I.
  using Frontier = SmallSet<BasicBlock::iterator, 8>;
  Frontier findFrontier(AAResults& aliasing, const DominatorTree& dt) const {
    MemoTable memo;
    return findFrontier(aliasing, dt, pos, memo);
  }

  BasicBlock::iterator pos;
  Value* def;
  Value* start;
  size_t start_offset;
  size_t len;

 private:
  using MemoTable = std::map<BasicBlock*, Frontier>;
  Frontier& findFrontier(AAResults& aliasing, const DominatorTree& dt,
                         BasicBlock::iterator cur, MemoTable& memo) const {
    BasicBlock* bb = cur->getParent();
    auto [it, inserted] = memo.try_emplace(bb);
    if (!inserted) {
      return it->second;
    }

    Frontier& frontier = it->second;

    if (pos->getParent() != bb && !dt.dominates(&*pos, bb)) {
      return frontier;
    }

    // Iterate through the instructions looking for an aliasing instruction.
    const auto loc = MemoryLocation{start, len};
    while (cur != bb->end()) {
      auto& inst = *cur;

      if (auto* branch = dyn_cast<BranchInst>(&inst)) {
        if (branch->isUnconditional()) {
          frontier = findFrontier(aliasing, dt,
                                  branch->getSuccessor(0)->begin(), memo);
          return frontier;
        } else {
          Frontier union_frontier;
          for (auto* succ : branch->successors()) {
            auto& succ_frontier =
                findFrontier(aliasing, dt, succ->begin(), memo);
            union_frontier.insert(succ_frontier.begin(), succ_frontier.end());
          }
          frontier = union_frontier;
          return frontier;
        }
      }

      // We don't know how to deal with other terminators, so we give up.
      if (inst.isTerminator()) {
        return frontier;
      }

      if (isModSet(aliasing.getModRefInfo(&inst, {loc}))) {
        frontier.insert(cur);
        return frontier;
      }

      ++cur;
    }
    UNREACHABLE();
  }
};

class CopyExtending : public FunctionPass {
 public:
  static char ID;
  CopyExtending() : FunctionPass(ID) {
    initializeCopyExtendingPass(*PassRegistry::getPassRegistry());
  }

  CopyExtending(const TargetMachine& target)
      : FunctionPass(ID), target_(&target) {
    initializeCopyExtendingPass(*PassRegistry::getPassRegistry());
  }

  bool runOnFunction(Function& func) override {
    auto& lvi = getAnalysis<LazyValueInfoWrapperPass>().getLVI();
    auto& alias = getAnalysis<AAResultsWrapperPass>().getAAResults();
    const auto& dt = DominatorTree{func};

    const auto& layout = target_->createDataLayout();

    SmallVector<PoisonRegion, 8> poison_regions;
    for (auto& bb : func) {
      for (auto& inst : bb) {
        if (auto poison = PoisonRegion::match(alias, layout, &inst)) {
          poison_regions.emplace_back(poison.value());
        }
      }
    }

    DenseMap<const PoisonRegion*, PoisonRegion::Frontier> frontiers;
    for (const auto& region : poison_regions) {
      frontiers.try_emplace(&region, region.findFrontier(alias, dt));
    }

    bool changed = false;
    for (const auto& [poison, frontier] : frontiers) {
      for (auto pos : frontier) {
        if (auto copy = BoundedCopy::match(lvi, layout, &*pos)) {
          // Check that the copy region is within the poison region
          if (poison->def != copy->dst_def ||
              copy->dst_start_offset < poison->start_offset ||
              copy->bound > (poison->start_offset + poison->len -
                             copy->dst_start_offset)) {
            continue;
          }

          // Check that the copy region is small enough to be worth copying
          if (copy->bound > 64) {
            continue;
          }

          // Check that the extended read is valid
          if (isSafeToRead(layout, copy->src_start, 0, copy->bound)) {
            IRBuilder<> builder(pos->getParent(), pos);
            copy->memcpy->setLength(builder.getInt64(copy->bound));
            changed = true;
          }
        }
      }
    }

    return changed;
  }

  void getAnalysisUsage(AnalysisUsage& usage) const override {
    usage.addRequired<AAResultsWrapperPass>();
    usage.addRequired<LazyValueInfoWrapperPass>();
  }

 private:
  const TargetMachine* target_ = nullptr;
};
}  // namespace

char CopyExtending::ID = 0;
INITIALIZE_PASS(CopyExtending, "copy-extending",
                "Extend memory copies of small fixed maximum size", false,
                false)
FunctionPass* llvm::createCopyExtendingPass(const TargetMachine& target) {
  return new CopyExtending(target);
}
