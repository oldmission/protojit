#pragma once

#include <iostream>
#include <sstream>
#include <unordered_set>

#include "arch.hpp"
#include "protogen.hpp"

namespace pj {

class SourceGenerator {
 public:
  SourceGenerator(const SourceId& outer_namespace)
      : outer_namespace_(outer_namespace), counter_(0) {}

  void addTypedef(const SourceId& name, types::ValueType type);
  void addProtocolHead(const SourceId& name, types::ValueType type,
                       types::PathAttr tag_path);

  void addProtocol(const SourceId& name, types::ProtocolType proto);

  // Recursively add subtypes if not added for wire types.
  void addComposite(types::ValueType type, bool is_external = false);

  void generateHeader(std::ostream& output,
                      const std::vector<std::filesystem::path>& imports);

 private:
  enum class Region { kDefs, kBuilders };

  // The type domain of the composite type that is currently being generated.
  // Host types have struct and enum definitions generated, and their build
  // methods are based on the host compiler's layout decisions. Wire types only
  // have build methods generated describing the exact layout of the MLIR types
  // as provided.
  enum class Domain { kUnset, kHost, kWire };

  void pushDomain(Domain domain) {
    assert(domain != Domain::kUnset);
    assert((depth_ == 0 && domain_ == Domain::kUnset) || domain_ == domain);
    domain_ = domain;
    depth_++;
  }

  void pushDomain(types::DomainAttr domain) {
    auto new_domain = Domain::kUnset;
    // .pj files are parsed into the InternalDomain, because the types do not
    // actually correspond to an actual in-memory type. However, since the
    // generated C++ code does describe an in-memory type, it should be
    // generated in HostDomain.
    if (domain.isa<types::InternalDomainAttr>()) {
      new_domain = Domain::kHost;
    } else if (domain.isa<types::WireDomainAttr>()) {
      new_domain = Domain::kWire;
    }
    pushDomain(new_domain);
  }

  void popDomain() {
    if (--depth_ == 0) {
      domain_ = Domain::kUnset;
    }
  }

  bool shouldAdd(types::ValueType type) {
    if (auto nominal = type.dyn_cast_or_null<types::NominalType>()) {
      // Host types must be added manually because they require additional
      // information.
      return nominal.domain().isa<types::WireDomainAttr>() &&
             generated_.find(type.getAsOpaquePointer()) == generated_.end();
    }
    return false;
  }

  std::stringstream& stream() {
    return region_ == Region::kDefs ? defs_ : builders_;
  }

  std::string getUniqueName() { return "_" + std::to_string(counter_++); }

  template <typename Name>
  void beginNamespaceOf(const Name& name) {
    for (std::string_view space : outer_namespace_) {
      stream() << "namespace " << space << "{";
    }
    for (size_t i = 0; i < name.size() - 1; ++i) {
      stream() << "namespace " << std::string_view(name[i]) << "{";
    }
  }

  template <typename Name>
  void endNamespaceOf(const Name& name) {
    for (size_t i = 0; i < outer_namespace_.size() + name.size() - 1; ++i) {
      stream() << "}\n";
    }
    stream() << "\n";
  }

  template <typename Name>
  std::string getNameAsString(const Name& name) {
    std::stringstream str;
    for (auto& p : outer_namespace_) str << "::" << p;
    for (auto& p : name) str << "::" << std::string_view(p);
    return str.str();
  }

  template <typename Name>
  void printName(const Name& name) {
    stream() << getNameAsString(name);
  }

  void printIntTypeRef(Width width, Sign sign);
  void printTypeRef(types::ValueType type);

  // Generates a variable containing a handle to a runtime type generated using
  // the type of the in-memory type, obtained using decltype
  std::string createTypeHandleFromDecl(std::string decl);

  // Generates a variable containing a handle to a runtime type generated by
  // explicitly calling the PJ API functions with the provided type information.
  // Assumes that the BuildPJType specializations available for nominal types
  // corresponds correctly to the provided type information.
  std::string createTypeHandleFromType(types::ValueType type);

  std::string buildStringArray(Span<llvm::StringRef> arr);

  void addStructDef(types::StructType type, bool decl_only);
  void addStructBuilder(types::StructType type, bool is_external);
  void addStruct(types::StructType type, bool is_external);

  void addVariantDef(types::VariantType type, bool has_value, Width tag_width,
                     bool decl_only);
  void addVariantBuilder(types::VariantType type, bool has_value,
                         Width tag_width, bool is_external);
  void addVariant(types::VariantType type, bool is_external);

  Region region_;
  Domain domain_ = Domain::kUnset;
  size_t depth_ = 0;
  std::stringstream defs_;
  std::stringstream builders_;
  std::unordered_set<const void*> generated_;

  SourceId outer_namespace_;
  size_t counter_;
};

}  // namespace pj
